---
title: "복잡한 카드게임 상태 관리를 useReducer로 깔끔하게 정리하기"
date: 2025-09-23
desc: useState를 사용할 때, 리렌더링 시 데이터를 유지하는 이유에 대해 정리한 글입니다.
thumbnail: /posts/커피빵/1.png
---

# 들어가며

커피빵 프로젝트의 카드게임 기능을 개발하면서, `CardGameProvider`의 상태 관리가 점점 복잡해지는 문제에 직면했습니다. 여러 상태들이 얽혀있고, 상태 전환 로직이 분산되어 있어 코드를 이해하고 유지보수하기가 어려워졌습니다.

이 글에서는 **useReducer를 활용해 복잡한 상태 관리를 체계적으로 정리한 리팩토링 과정**을 작성해보려고 합니다.

# 기존 코드의 문제점

## 문제 상황 분석

기존 `CardGameProvider`는 다음과 같은 문제점들을 가지고 있었습니다.

```jsx
const CardGameProvider = ({ children }: PropsWithChildren) => {
  // 1. 개별 상태들이 분산되어 관리됨
  const [isTransition, setIsTransition] = useState<boolean>(false);
  const [currentRound, setCurrentRound] = useState<RoundType>('FIRST');
  const [currentCardGameState, setCurrentCardGameState] = useState<CardGameState>('READY');
  const [cardInfos, setCardInfos] = useState<CardInfo[]>([]);

  const handleCardGameState = useCallback((data: CardGameStateResponse) => {
    const { cardGameState, currentRound, cardInfoMessages } = data;

    // 2. 복잡한 조건문들
    const isPreparing = cardGameState === 'PREPARE';
    const isFirstRoundPlaying = cardGameState === 'PLAYING' && currentRound === 'FIRST';
    const isFirstRoundScoreBoard = cardGameState === 'SCORE_BOARD' && currentRound === 'FIRST';
    // ... 더 많은 조건문들

    // 3. 중복된 로직과 분산된 상태 업데이트
    if (isPreparing) {
      setCurrentCardGameState('PREPARE');
      setCardInfos(cardInfoMessages);
      return;
    }

    if (isFirstRoundPlaying) {
      setCurrentCardGameState('PLAYING');
      setCardInfos(cardInfoMessages);
      // 중복된 selectedCardInfo 업데이트 로직...
      return;
    }
    // ...
  }, [/* 많은 의존성들 */]);
};

```

<br />

## 핵심 문제점들

1\. **과도한 책임**: `handleCardGameState` 함수가 모든 상태 전환을 담당

2\. **상태 동기화 이슈**: 여러 `setState` 호출로 인한 일시적 불일치 가능성

3\. **중복 코드**: 카드 정보 업데이트 패턴이 여러 곳에서 반복

4\. **복잡한 조건문**: 새로운 상태 추가 시 기하급수적 복잡도 증가

<br />

# 리팩토링 계획

이런 문제들을 해결하기 위해 아래와 같은 전략을 세웠습니다.

1\. **관심사 분리**: 상태 관리와 사이드 이펙트 로직 분리

2\. `useReducer` **도입**: 연관된 상태들의 원자적 업데이트

3\. **커스텀 훅 활용**: 재사용 가능한 로직 모듈화

<br />

# 리팩토링 과정

## 1단계: 핸들러 함수 분리

먼저 거대한 `handleCardGameState` 함수를 상태별로 분리했습니다.

```jsx
// Before: 하나의 거대한 함수
const handleCardGameState = (data) => {
  if (isPreparing) {
    setCurrentCardGameState("PREPARE");
    setCardInfos(cardInfoMessages);
    return;
  }
  // 복잡한 로직
};

// After: 명확한 책임을 가진 개별 함수들
const handlePrepare = useCallback((cardInfoMessages: CardInfo[]) => {
  setCurrentCardGameState("PREPARE");
  setCardInfos(cardInfoMessages);
}, []);

const handleCardGameState = useCallback((data) => {
  const { cardGameState, currentRound, cardInfoMessages } = data;

  switch (cardGameState) {
    case "PREPARE":
      handlePrepare(cardInfoMessages);
      break;
    case "PLAYING":
      handlePlaying(cardInfoMessages, currentRound);
      break;
    // ...
  }
}, []);
```

<br />

## 2단계: useReducer 도입

연관된 상태들을 하나의 reducer로 통합했습니다.

```jsx
// 상태 타입 정의
export type State = {
  isTransition: boolean,
  currentRound: RoundType,
  currentCardGameState: CardGameState,
  cardInfos: CardInfo[],
};

// 액션 타입 정의 - 도메인 중심의 액션
export type Action =
  | { type: "PREPARE", payload: { cardInfos: CardInfo[] } }
  | { type: "PLAYING", payload: { cardInfos: CardInfo[], round: RoundType } }
  | {
      type: "SCORE_BOARD",
      payload: { cardInfos: CardInfo[], round: RoundType },
    }
  | { type: "LOADING", payload: { currentRound: RoundType } }
  | { type: "DONE" };

// Reducer 구현
export const cardGameReducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "PREPARE":
      return {
        ...state,
        currentCardGameState: "PREPARE",
        cardInfos: action.payload.cardInfos,
      };

    case "PLAYING":
      return {
        ...state,
        currentCardGameState: "PLAYING",
        cardInfos: action.payload.cardInfos,
        currentRound: action.payload.round,
        isTransition:
          action.payload.round === "SECOND" ? false : state.isTransition,
      };
    // ...
  }
};
```

<br />

## 3단계: 커스텀 훅으로 로직 분리

상태 관리와 핸들러 로직을 별도의 훅으로 분리했습니다.

```jsx
// useCardGameState.ts - 순수한 상태 관리
export const useCardGameState = () => {
  const [state, dispatch] = useReducer(cardGameReducer, initialState);

  return {
    state,
    dispatch,
    // 편의를 위한 개별 상태 접근
    isTransition: state.isTransition,
    currentRound: state.currentRound,
    currentCardGameState: state.currentCardGameState,
    cardInfos: state.cardInfos,
  };
};

// useCardGameHandlers.ts - 비즈니스 로직 처리
export const useCardGameHandlers = ({ dispatch, updateSelectedCardInfo }) => {
  const navigate = useNavigate();
  const { joinCode } = useIdentifier();
  const { miniGameType } = useParams();

  const handleCardGameState = useCallback(
    (data: CardGameStateResponse) => {
      const { cardGameState, currentRound, cardInfoMessages } = data;

      switch (cardGameState) {
        case "PREPARE":
          dispatch({
            type: "PREPARE",
            payload: { cardInfos: cardInfoMessages },
          });
          break;

        case "PLAYING":
          dispatch({
            type: "PLAYING",
            payload: { cardInfos: cardInfoMessages, round: currentRound },
          });
          // 사이드 이펙트: 카드 선택 정보 업데이트
          updateSelectedCardInfo(cardInfoMessages, currentRound);
          break;

        case "DONE":
          dispatch({ type: "DONE" });
          // 사이드 이펙트: 페이지 네비게이션
          navigate(`/room/${joinCode}/${miniGameType}/result`);
          break;
        // ...
      }
    },
    [dispatch, updateSelectedCardInfo, navigate, joinCode, miniGameType]
  );

  return { handleCardGameState };
};
```

<br />

# 리팩토링 결과와 개선점

## 최종 CardGameProvider

리팩토링 후 `CardGameProvider`는 훨씬 간결해졌습니다.

```jsx
const CardGameProvider = ({ children }: PropsWithChildren) => {
  const { joinCode, myName } = useIdentifier();

  // 상태 관리
  const {
    dispatch,
    isTransition,
    currentRound,
    currentCardGameState,
    cardInfos,
  } = useCardGameState();

  // 선택된 카드 관리
  const { selectedCardInfo, updateSelectedCardInfo } = useSelectedCard(myName);

  // 게임 상태 핸들러
  const { handleCardGameState } = useCardGameHandlers({
    dispatch,
    updateSelectedCardInfo,
  });

  // WebSocket 구독
  useWebSocketSubscription(`/room/${joinCode}/gameState`, handleCardGameState);

  return (
    <CardGameContext.Provider
      value={{
        isTransition,
        currentRound,
        currentCardGameState,
        cardInfos,
        selectedCardInfo,
      }}
    >
      {children}
    </CardGameContext.Provider>
  );
};
```

<br />

# 기존 코드와 달라진 점

## 1. 원자적 상태 업데이트

**Before**: 여러 `setState` 호출로 인한 동기화 이슈

```jsx
// 비동기적 상태 업데이트로 일시적 불일치 가능
updateCardGameState("PLAYING");
updateCardInfos(newCards);
updateCurrentRound("SECOND");
updateTransition(false);
```

**After**: 하나의 액션으로 일관된 상태 보장

```jsx
// 모든 관련 상태가 원자적으로 업데이트됨
dispatch({
  type: "PLAYING",
  payload: { cardInfos: cardInfoMessages, round: currentRound },
});
```

<br />

## 2. 의존성 간소화

**Before**: 5개의 개별 업데이트 함수 필요

```jsx
const handlers = useCardGameHandlers({
  updateCardGameState, // 1
  updateCardInfos, // 2
  updateCurrentRound, // 3
  updateTransition, // 4
  updateSelectedCardInfo, // 5
});
```

**After**: 단일 dispatch 함수만 필요

```jsx
const handlers = useCardGameHandlers({
  dispatch, // 하나의 함수만!
  updateSelectedCardInfo, // 사이드 이펙트용
});
```

<br />

## 3. 명확한 관심사 분리

- **Reducer**: 순수한 상태 전환 로직만 담당
- **Handler**: 사이드 이펙트(API 호출, 네비게이션) 처리
- **Provider**: 훅들의 조합과 Context 제공

<br />

## 4. 향상된 가독성과 유지보수성

**Before**: 복잡한 조건문과 분산된 로직

```jsx
const isPreparing = cardGameState === "PREPARE";
const isFirstRoundPlaying =
  cardGameState === "PLAYING" && currentRound === "FIRST";

if (isPreparing) {
  // 복잡한 로직
}
```

**After**: 직관적인 액션 기반 처리

```jsx
switch (cardGameState) {
  case "PREPARE":
    dispatch({ type: "PREPARE", payload: { cardInfos } });
    break;
  // 각 케이스의 의도가 명확함
}
```

<br />

# 배운 점

리팩토링을 통해 학습한 내용을 정리해 보았습니다.

<br />

## useReducer가 적합한 상황

이번 리팩토링을 통해 `useReducer`가 특히 유용한 상황들을 정리해볼 수 있었습니다.

1\. **연관된 상태들이 함께 변경**되는 경우
2\. **상태 전환 로직이 복잡**한 경우
3\. **여러 컴포넌트에서 동일한 상태 로직**을 사용하는 경우

## 설계 원칙의 중요성

- **도메인 중심 액션**: `UPDATE_CARD_GAME_STATE` 대신 `PREPARE`, `PLAYING` 같은 도메인 용어를 사용하다는 것이 중요하다는 것을 알게 되었습니다.
- **사이드 이펙트 분리**: `Reducer`에서는 순수한 상태 변경만, 사이드 이펙트는 별도 처리를 하는 것이 더 깔끔하다는 것을 알 수 있었스빈다.
- **단일 책임 원칙**: 각 훅과 함수가 명확한 하나의 책임만 담당하도록 하는 것이 중요하다는 것을 알 수 있었습니다.

<br />

# 마치며

복잡한 상태 관리를 `useReducer`로 리팩토링한 결과, 각 파일의 책임이 분리되어 **코드를 디버깅하기 쉬워**졌고, **예측 가능성과 유지보수성이 향상**되었습니다. 특히 연관된 여러 상태를 원자적으로 관리할 수 있게 되어 상태 동기화 이슈를 원천적으로 해결할 수 있었습니다.

물론 `useReducer`가 모든 상황에 적합한 것은 아니지만, **복잡한 상태 전환 로직**을 다룰 때는 `useReducer`로 사용하는 것이 유용하다는 것을 깨달았습니다.

앞으로도 상태 관리의 복잡도가 증가할 때마다, 이번 리팩토링에서 얻은 경험을 바탕으로 더 나은 설계를 고민해보려고 합니다.
