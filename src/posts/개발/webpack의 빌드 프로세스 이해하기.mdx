---
title: "webpack의 빌드 프로세스 이해하기"
date: 2025-11-21
desc: Webpack이 빌드 시 수행하는 과정을 Entry Point부터 최종 산출물까지 따라가 봅니다.
thumbnail: /posts/개발/5/thumbnail.png
---

# 들어가며

프로젝트에서 **npm run build**를 실행하면 뭔가 많은 일이 일어나는 것 같은데, 정확히 어떤 과정을 거쳐 최종 결과물이 만들어지는지 궁금했습니다. Webpack 설정 파일은 있지만 **각각의 설정이 어느 단계에서 어떤 역할을 하는지 명확하게 이해**하고 싶어서 정리하게 되었습니다.

이 글에서는 커피빵 프로젝트의 실제 Webpack 설정을 예시로, 빌드 명령어 실행부터 최종 산출물이 나오기까지의 전 과정을 단계별로 살펴보겠습니다.

**커피빵 프로젝트의 Webpack 설정**은 [여기](https://github.com/woowacourse-teams/2025-coffee-shout/blob/fe/dev/frontend/webpack.common.js)에서 확인할 수 있습니다.

<br />

## **빌드 프로세스 전체 흐름**

먼저 전체 흐름을 보면 이해하기 쉬울 것 같아서 첨부합니다.

1\. **npm run build** 실행

2\. **webpack 초기화**

3\. **환경 설정** (.env 파일 읽기)

4\. **의존성 그래프 구축 & 각 파일에 Loader 적용**
(Entry 경로에서 AST를 생성하며 모든 파일이 Javascript로 변환 및 저장)

5\. **번들링** (파일들을 하나로 합치기)

6\. **최적화** (압축, Tree Shaking, Code Splitting, Terser)

7\. **Plugin 실행** (HTML 생성, 파일 복사, 소스맵 업로드 등)

8\. **dist 폴더에 최종 결과물 출력**

<br />

이제 각 단계를 상세하게 살펴보겠습니다.

### **1.** npm run build 실행 시 **webpack 초기화**

```jsx
// package.json
{
  "scripts": {
    "build": "webpack --mode production"
  }
}
```

`npm run build` 명령어가 실행되면 Webpack은 프로젝트 루트의 `webpack.config.js` 파일을 찾아서 읽습니다. 이때 `--mode production` 옵션으로 프로덕션 모드가 설정되며, 이 모드에서는 자동으로 최적화가 활성화됩니다.

```jsx
export default (_, argv) => {
    const mode = argv.mode || "development"; // 'production
    // ...
};
```

<br />

### **2. 환경 변수 설정 및 주입**

```jsx
dotenv.config({ path: path.resolve(process.cwd(), `.env.${mode}`) }).parsed || {}; // webpack.config.js에서 환경 읽기

new webpack.DefinePlugin(envKeys); // 코드에 주입
```

`DefinePlugin`은 빌드 시점에 코드 내의 환경 변수를 실제 값으로 치환합니다. 개발 환경과 프로덕션 환경에서 다른 API 엔드포인트를 사용해야 할 때 유용합니다.

<br />

### **3. Entry Point에서 의존성 그래프 구축 & Loader 적용**

```jsx
entry: "./src/main.tsx";
```

**Webpack**은 **Entry Point**로 지정된 파일부터 시작해서 모든 `import` 문을 재귀적으로 추적합니다. 이 과정을 **의존성 그래프 구축**이라고 하며, Webpack은 이 그래프를 메모리에 저장하여 어떤 파일이 필요한지 정확히 파악합니다.

<br />

예를 들어, 아래와 같은 파일의 import 경로가 있을 때 webpack은 해당 파일을 읽으면서 Loader를 적용하여 의존성 그래프 정보를 구축합니다.

```jsx
// main.tsx (Entry Point)
import { GamePage } from "./GamePage.tsx";
import "./styles/global.css";
```

<br />

현재 GamePage에 대한 파일 경로를 발견했으니, Loader를 적용하여 import 구문을 파싱하고, global.css를 발견했으니 css-loader를 적용하여 import 구문을 파싱한 후 그래프에 추가합니다.

이후 해당 파일에서 발견하는 파일 경로들에 대해서 재귀적으로 타고 내려갑니다.

<br />

정리하자면 의존성 그래프 구축 과정에서는 아래와 같은 일들이 발생합니다.

1\. **변환** : Loader가 파일을 Javascript로 변환

2\. **파싱** : 변환된 코드에서 import/require 구문 찾기

3\. **저장** : 의존성 정보를 그래프 자료구조에 저장

4\. **재귀** : 발견된 모든 의존성에 대해서 1~3 반복

<br />

### **각 파일들에 적용되는 Loader는 어떤 것들이 있나요?**

추가적으로, 각 파일의 확장자 별로 처리되는 Loader는 다음과 같습니다.

webpack은 각각의 파일을 처리할 때, 적절한 loader를 선택해서 적용합니다. 파일 확장자를 보고 어떤 loader를 사용할지 결정합니다.

<br />

**(1) Typescript/TSX 파일**

```jsx
{ test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ }
```

`.ts`나 `.tsx` 파일은 **ts-loader**에 의해서 처리되는데요. 여기서 **ts-loader**의 역할은 아래와 같습니다.

1\. **tsc**(TypeScript Compiler)를 활용하여 **타입 체크**를 수행

2\. **Typescript → Javascript 컴파일 : 타입 제거**

    ```jsx
    // Before: TypeScript
    interface **GameCardProps** {
      players: number;
    }

    export const GameCard: React.FC<**GameCardProps**> = ({ players }) => { }

    // After: JavaScript
    export const GameCard = ({ title, players, onJoin }) => { }
    ```

3\. **JSX → React.createElement로 변환**

    ```jsx
    // Before: JSX
    <div className="player-count">
        <span>{players}명 참가중</span>
    </div>;

    // After: React.createElement
    React.createElement(
        "div",
        { className: "player-count" },
        React.createElement("span", null, players + "명 참가중")
    );
    ```

<br />

현재, 저희 프로젝트는 ts-loader를 사용했기 때문에 ts-loader의 관점에서 설명했습니다. babel-loader는 타입 검증을 제외하고는 동일한 과정을 거치는 것으로 알고 있습니다.

<br />

**(2) 이미지 파일**

```jsx
{
  test: /\.(png|svg|jpg|jpeg|gif|webp)$/i,
  type: 'asset/resource',
  generator: {
    filename: (pathData) => '[name].[contenthash][ext]'; // card.dsfdf.png
  },
}
```

빌드 과정에서 이미지 파일에 대한 import 문을 만나면 Webpack은 다음 과정을 수행합니다.

```jsx
import card from "@/assets/images/card.png";
```

1\. **이미지 파일을 dist 폴더로 복사** : `assets/images/card.png` → `dist/card.hashValue.png`

2\. **파일 내용의 해시값 계산** : card.png의 내용을 특정 해시 함수 적용해서 나온 값으로 해시 생성(파일 내용이 1바이트라도 달라지면 해시값이 완전 달라짐)

3\. **import 경로를 실제 파일 경로로 변환** : `var card = “/card.hashValue.png”`

<br />

이렇게 되면 브라우저는 이미 경로가 치환된 경로(`“/card.hashValue.png”`)를 받기 때문에 실제로 배포환경의 dist 폴더에서 해당 경로로 바로 접근할 수 있습니다.

<br />

**(3) CSS 파일**

```jsx
{ test: /\.css$/i, use: ['style-loader', 'css-loader'] }
```

css 파일에 대한 확장자를 만나면, 2가지의 loader를 실행하는데요.

여러 개의 loader가 있을 때, **Loader**는 오른쪽에서 왼쪽으로 실행됩니다.

<br />

```jsx
/* src/styles/gameCard.css */
.game-card {
  background-color: #ffffff;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
}
```

1\. **css-loader** : css 파일을 읽어서 **Javascript가 이해할 수 있는 형태**로 변환

    - @import를 해석하거나, url(), CSS Module을 해석하는 역할을 합니다.

    ```jsx
    // CSS가 JavaScript 객체로 변환
    module.exports = {
        toString: function () {
            return ".game-card{background-color:#fff;border-radius:12px;padding:24px;box-shadow:0 2px 8px rgba(0,0,0,.1);transition:all .3s ease}";
        },
    };
    ```

2\. **style-loader** : 위에서 Javascript로 변환된 CSS를 **style 태그로 dom에 삽입**

    ```jsx
    // 번들에 포함되는 코드
    (function () {
        var css =
            ".game-card{background-color:#fff;border-radius:12px;padding:24px;box-shadow:0 2px 8px rgba(0,0,0,.1);transition:all .3s ease}";

        var style = document.createElement("style");
        style.appendChild(document.createTextNode(css));
        document.head.appendChild(style);
    })();
    ```

    참고로, style-loader가 빌드 타임에 하는 것은 실제로 DOM에 스타일을 추가하는 것이 아니라, **런타임에 DOM에 스타일을 추가할 코드를 생성**하는 과정입니다.

    정리하자면, **style-loader**는 빌드 타임과 런타임에서 모두 동작하며 각 타임에는 아래와 같이 동작합니다.

    1\. **빌드 타임** : **DOM에 주입하는 코드를 생성**하여 번들에 포함

    2\. **런타임** : 그 코드가 **브라우저에서 실제로 실행**되어 **스타일을 주입**

<br />

즉, css 파일을 처리하고 나면 런타임 시 브라우저에서 아래와 같이 스타일 태그 내부에 스타일이 잘 포함된 것을 볼 수 있습니다.

<img src="/posts/개발/5/image.png" width="300px" />

<br />

정리하자면 아래와 같습니다.

```jsx
빌드 타임 (npm run build)
  ├─ 1) css-loader 실행
  └─ 2) style-loader 실행
       └─ 생성된 코드는 번들에 포함

런타임 (브라우저)
  └─ style-loader가 생성한 코드가 실행됨
       └─ <style> 태그가 DOM에 추가됨
```

<br />

### 그럼 css 파일이 별도로 분리되어서 다운로드되는 경우는 어떻게 가능한거죠?

보통 css 파일을 따로 받는 경우도 있는데, 이건 style-loader 대신에 `MiniCssExtractPlugin.loader`를 쓸 때 가능합니다.

**style-loader 방식**은 css 파일이 JS에 포함되기 때문에, main.js 번들 파일에 css가 포함되지만,

**MiniCssExtractPlugin**을 사용하면 css 파일이 분리된 방식으로 동작합니다.

<br />

그 결과 빌드 파일은 main.js와 main.hashValue.css와 같이 별도의 css 파일이 분리된 방식으로 동작하며, 실제로 index.html 내부에 link 태그로 연결됩니다. 이렇게 MiniCssExtractPlugin을 사용하면 모든 css를 하나의 파일로 합쳐서 **HTMLWebpackPlugin이 자동으로 link 태그를 추가**한다고 합니다.

<br />

### 4. 번들링

이렇게 모든 파일이 Javascript 모듈로 변환되었다면, Webpack 코어는 모든 파일을 하나의 파일로 합치는 번들링 과정을 수행합니다.

사실상 Entry Point로부터 의존성 그래프를 구축하고, loader를 적용하여 모든 파일을 합치기까지의 과정을 번들링이라고 할 수 있습니다.

<br />

### 5. 최적화

초기 번들링이 있고 나서, 이후에는 최적화를 시작합니다. 이때 CodeSplitting, Tree Shaking, Terser 등의 작업이 실행됩니다. 해당 최적화 작업이 끝나고 나서야 최종적인 청크가 생성됩니다.

현재 커피빵의 설정은 아래와 같은데요. 실제로 각 최적화 작업은 특정 순서에 의해 발생되는 것으로 알고 있지만, 해당 글에서는 순서보다는 어떤 최적화 단계가 있는지를 중심으로 작성했습니다.

```jsx
optimization: {
      usedExports: true,
      sideEffects: false,

      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
          },
        },
      },
```

<br />

### 5-1. 트리셰이킹

`Tree Shaking`은 **사용하지 않는 코드를 제거**하는 최적화 기법입니다. 최종 번들에는 실제로 사용하는 코드만 포함되어 번들 크기가 줄어듭니다.

```jsx
optimization: {
  usedExports: true,    // 사용하는 export만 표시
  sideEffects: false,   // 부작용 없는 코드 제거 허용
}
```

먼저, 설정에 있는 **useExports를 분석**하고, 현재 사용되는 export만 표시하도록 설정(true)되어 있으므로, 실제 번들 파일 내부에 사용되지 않는 파일이라는 표식을 작성합니다.

이러한 표식은 추후 Terser가 실제로 제거하는데요. 트리셰이킹 단계에서는 주석으로 unused 표식을 남기고 실제로 제거하는 것은 Terser가 수행합니다.

<br />

또한 **sideEffect**란 **모듈을 import 했을 때, export를 사용하지 않아도 실행되는 코드**를 의미하는데요. 실제로 이렇게 **sideEffects** 설정이 false이므로 부작용이 있는 파일이 없다는 것을 명시합니다.

<br />

### 5-2. 코드 스플리팅

**초기 번들에 의해서 합쳐졌던 번들 파일을 여러 개의 청크로** 나눕니다.

```jsx
splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
          },
        },
```

이는 모든 코드가 하나의 번들에 의해 포함되는 경우, 현재 안보는 페이지들을 포함해서 다운로드 할 필요가 없기 때문입니다.

<br />

### 5-3. 코드 압축 및 난독화

이후 `Terser`가 실행됩니다. `Terser`가 하는 역할은 다음과 같습니다.

1\. 사용되지 않는 코드 제거 (조건부 실행)

2\. 공백이나 줄바꿈, 주석 제거

3\. 변수명을 난독화하여 짧게 변경

```jsx
// Terser 적용 전
function calculateTotalPrice(items) {
    let totalPrice = 0;
    for (let i = 0; i < items.length; i++) {
        totalPrice += items[i].price;
    }
    return totalPrice;
}

// Terser 적용 후 (Minification + Mangling)
function a(b) {
    let c = 0;
    for (let d = 0; d < b.length; d++) c += b[d].price;
    return c;
}
```

현재 저희 프로젝트의 설정에는 포함되지 않았지만 `Terser`는 production 모드에서는 기본값이 true로 동작하기 때문에 별도의 설정 없이도 코드 압축이 이루어집니다.

<br />

### 6. 파일명 해싱

```jsx
output: {
  filename: '[name].[contenthash].js',
  chunkFilename: '[name].[contenthash].chunk.js',
}
```

여기서 `contenthash`란 파일의 내용을 기반으로 생성된 해시값으로, SHA-256 알고리즘을 사용하여 내용이 조금이라도 변경되면 해시가 완전히 달라집니다.

<br />

### 7. 플러그인 실행

마지막으로 플러그인을 실행합니다. 프로젝트 내부에서 사용한 플러그인은 아래와 같습니다.

<br />

1\. **HTMLWebpackPlugin**

**역할 :** 번들된 js 파일을 자동으로 참조하는 HTML 파일을 생성합니다.

**필요한 이유**

-   main.js는 해시값이 붙어서 생성되기 때문에, 해시값이 달라지면 매번 변경되는데요. 이때 **매 빌드마다 내용이 달라지면 해시값이 달라지기 때문에, html에서 항상 다르게 참조**해야 합니다.
-   즉, 해시값이 달라질 때마다 수정해야 하기 때문에, **HtmlWebpackPlugin을 통해서 변경된 파일명을 참조하여 script 태그로 자바스크립트를 삽입하여 html 파일을 다시 생성**해줍니다.

<br />

2\. **CopyWebpackPlugin** : 정적 파일 복사 (font, robot.txt, sitemap 등)

**역할** : **빌드 과정을 거치지 않는 정적 파일들을 dist 폴더로 그대로 복사**하는 플러그인입니다.

**필요한 이유**

-   일부 파일들은 webpack의 변환이 필요없고, 그대로 복사하면 되기 때문입니다.

<br />

# 정리

**npm run build** 명령어 하나로 webpack은 복잡한 8단계의 작업을 수행합니다.

**1-3단계: 준비**

-   Webpack 초기화 및 환경 설정
-   Entry Point부터 의존성 그래프 구축
-   각 파일에 적절한 Loader 적용 (TS→JS, CSS→JS, 이미지 처리)

<br />

**4-5단계: 번들링 & 최적화**

-   변환된 모듈들을 하나의 번들로 결합
-   Tree Shaking으로 사용하지 않는 코드 제거
-   Code Splitting으로 청크 분리
-   Terser로 코드 압축 및 난독화

<br />

**6-7단계: 최종 산출물 생성**

-   파일명에 contenthash 추가
-   HTMLWebpackPlugin으로 번들 파일을 참조하는 HTML 생성
-   정적 파일 복사 및 최종 파일 출력

<br />

# 마무리하며

웹팩의 빌드 과정을 이해하면서 많은 것을 배울 수 있었습니다. 처음에는 설정 파일을 단순히 복사해서 사용했지만, 이제는 각 설정이 왜 필요한지, 빌드 과정에서 어떤 역할을 하는지 알게 되었습니다.
이런 이해를 바탕으로 문제가 발생했을 때 어디를 먼저 확인해야 할지 감이 잡히고, 더 효과적으로 디버깅할 수 있게 되었습니다.

<br />

이 글을 읽고 웹팩의 동작 원리를 이해하는 데 도움이 되었으면 좋겠습니다.

감사합니다.

<br />

# 참고

[https://webpack.kr/concepts/](https://webpack.kr/concepts/)
