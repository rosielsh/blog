---
title: "효율적으로 웹 캐시 관리하기 (S3, CloudFront)"
date: 2025-11-16
desc: 브라우저, CloudFront, S3 각 레이어에서의 캐싱 전략과 리소스별 캐싱 방법을 정리했습니다.
thumbnail: /posts/개발/6/thumbnail.png
---

# 들어가며

이번 커피빵 서비스에 이미지 캐싱을 적용하면서, 브라우저, CloudFront, S3 등 다양한 레이어에서 캐싱을 설정할 수 있다는 것을 알게 되었습니다. 하지만 각 상황에서 어떤 방식으로 캐싱을 적용해야 하는지에 대한 명확한 기준이 없어 헷갈리는 개념들이 많았습니다. 이 글에서는 그러한 개념들을 정리하고자 합니다. 현재 저희 서비스는 S3와 CloudFront로 배포하는 구조이기 때문에, 해당 스펙에 대한 내용이 포함되어 있다는 점을 참고해주시기 바랍니다.

<br />

# 캐싱을 적용하게 된 배경

<img src="/posts/개발/6/1.png" width="400px" />

이런 이미지들이 매번 다운로드된다면 페이지 로딩 시간이 길어지고, 결과적으로 사용자 이탈률이 증가하게 됩니다.

불필요한 요청이라고 판단했고, 아예 요청을 보내지 않는 것이 효율적이라고 생각하여 이미지 캐싱을 적용하게 되었습니다.

<br />

<img src="/posts/개발/6/2.png" width="400px" />

또한 메인 페이지의 로고 이미지가 LCP 요소로 측정되면서 성능 지표가 저하되었고, 이를 개선하기 위한 목적도 있었습니다.
초기 목적은 이미지 캐싱이었지만, 다른 리소스들에 대한 캐싱 전략도 함께 학습하여 서비스 전반의 캐싱이 잘 관리되고 있는지 확인하는 과정이 필요하다고 판단했습니다.

<br />

# 우리 서비스에서 가능한 캐싱 전략

그렇다면 캐싱을 어떤 식으로 적용할 수 있을까요?

처음에는 브라우저가 캐싱을 알아서 해주지 않나?라고 생각했었는데, 조금 더 학습해보니 요청을 거쳐가는 인프라 단에서도 캐싱을 적용할 수 있다는 것을 알게 되었습니다.

현재 우리 클라이언트 단의 서비스 구조는 S3 + Cloudfront로 이루어져 있습니다. 따라서 이미지 캐싱 전략은 브라우저까지 포함하면 크게 3개의 레이어에서 관리할 수 있습니다.

<br />

<img src="/posts/개발/6/3.png" width="600px" />

<br />

각각의 레이어에서 가능한 캐싱 방식을 알아보겠습니다.

<br />

### 1. S3(Origin)

실제 원본 데이터가 저장되는 곳이고, 여기서는 **기본적으로 캐싱 관련 헤더를 설정해두는 역할**을 합니다.

**원본의 캐싱 정책을 정의하고, Cloudfront가 이 헤더를 참고**합니다.

<br />

여기서 설정 가능한 대표적인 헤더는 아래와 같습니다.

<table>
    <thead>
        <tr>
            <th>헤더</th>
            <th>의미</th>
            <th>추천 설정</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <strong>Cache-Control</strong>
            </td>
            <td>리소스의 유효 기간에 대한 설정</td>
            <td>
                <code>public, max-age=31536000, immutable</code>
            </td>
        </tr>
        <tr>
            <td>
                <strong>Content-Type</strong>
            </td>
            <td>파일 타입</td>
            <td>
                <code>image/png</code>, <code>image/jpeg</code>, <code>image/webp</code> 등
            </td>
        </tr>
        <tr>
            <td>
                <strong>ETag</strong>
            </td>
            <td>파일 콘텐츠 기반 해시</td>
            <td>S3가 자동 생성</td>
        </tr>
        <tr>
            <td>
                <strong>Last-Modified</strong>
            </td>
            <td>마지막 수정 시간</td>
            <td>S3 자동</td>
        </tr>
    </tbody>
</table>

보통 **CI/CD 파이프라인에서 파일을 업로드 할 때나 수동으로 파일을 올릴 때에 설정**할 수 있는데요.

yaml 파일에 아래와 같이 작성할 수 있습니다.

```jsx
# GitHub Actions 예시
- name: Deploy to S3
  run: |
    aws s3 sync ./dist s3://bucket \
      --cache-control "public,max-age=31536000,immutable" \
      --exclude "*.html"
```

<br />

참고로 `Cache-Control`에 적용되는 설정의 의미는 아래와 같습니다.

<br />

1\. **캐시 적용에 사용되는 설정**

-   **max-age** : 유효한 캐시 기간 (최대 1년 = 31,536,000초)
-   **s-maxage** : cdn과 같은 공유 캐시에서는 s-maxage의 값을 먼저 적용
-   **Expires** : 유효기간 (max-age보다 후순위)
-   **no-cache** : 캐시 가능하지만 origin 서버에 매번 캐시 검증 요청 보냄
-   **no-store** : 캐시 불가능. 매번 서버에서 새로 받아옴

<br />

2\. **캐시 검증에 사용되는 설정**

캐시를 읽었는데 유효 기간이 지났다면 클라이언트는 서버에게 유효한 데이터인지 요청을 하게 됩니다.

-   기존 응답 헤더에 **Last-Modified**가 있었다면 → **캐시의 Last-Modified** 값을 If-Modified-Since에 넣고 서버에 요청
-   기존 응답 헤더에 **ETag**가 있었다면 → **캐시의 ETag** 값을 헤더에 넣고 서버에 요청

<br />

3\. **public / private**

중간 단계에 있는 서버에서도 캐시를 저장할지에 대한 설정을 해주는 옵션입니다.

-   **public** : 중간 프록시 서버(ex) CDN)에서도 캐시를 저장할 수 있습니다.
-   **private** : 최종 끝에 있는 클라이언트에서만 캐시를 저장할 수 있습니다.

<br />

### 2. Cloudfront(CDN)

Cloudfront는 브라우저와 S3 사이의 캐시 레이어 역할을 하고, 전 세계의 엣지 서버에 해당합니다.

CDN 엣지 서버에서 얼마나 오래 캐싱할지를 결정합니다.

<br />

여기서 설정할 수 있는 주요 옵션은 다음과 같습니다.

<table>
    <thead>
        <tr>
            <th>옵션</th>
            <th>설명</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <strong>TTL (Cache TTL)</strong>
            </td>
            <td>CloudFront가 캐싱을 유지하는 시간</td>
        </tr>
        <tr>
            <td>
                <strong>Origin Cache-Control respect</strong>
            </td>
            <td>S3의 Cache-Control을 그대로 따를지 여부</td>
        </tr>
        <tr>
            <td>
                <strong>Query string / header / cookie based cache</strong>
            </td>
            <td>URL 파라미터에 따라 캐시 구분 가능</td>
        </tr>
    </tbody>
</table>

여기서 말하는 TTL은 Cloudfront에서 얼마나 오래 캐싱할지를 의미하며, 아래의 값들을 설정해줄 수 있습니다.

<br />

-   **Default TTL**: 별도로 만료 헤더가 없을 때 기본으로 사용하는 시간
-   **Minimum TTL**: TTL보다 짧게 요청이 들어오면 최소 이 시간 동안은 캐싱
-   **Maximum TTL**: TTL보다 길게 요청이 들어오면 최대 이 시간까지만 캐싱

<br />

또한 **Origin Cache-Control respect**를 true로 설정하면 S3에서 설정한 헤더를 그대로 참고한다는 뜻이고 false로 설정하면 Cloudfront의 TTL 설정을 우선으로 한다는 의미입니다.

```jsx
Use Origin Cache Headers = true → Origin 기준 캐싱
Use Origin Cache Headers = false → CloudFront의 TTL 설정이 우선
```

<br />

### 3. Browser (Client)

최종적으로 브라우저는 **Cloudfront가 내려준 헤더를 보고 캐싱할 지 판단**합니다.

**사용자가 웹 사이트를 접속할 때 결정되며, 브라우저가 S3/Cloudfront에서 받은 헤더를 자동으로 해석**합니다.

<br />

브라우저의 캐싱 동작 방식은 아래와 같습니다.

1\. max-age동안은 네트워크의 요청 없이 로컬 캐시에 저장된 이미지를 사용

2\. immutable이면 사용자가 새로고침해도 변경 확인 요청 없음

3\. 파일이 변경되었을 때는 파일명을 통해 강제 갱신

<br />

### 만약에 어디서든 캐시 설정을 해주지 않는다면?

브라우저가 마음대로 설정합니다. 이를 휴리스틱 캐싱이라고 합니다.

하지만 브라우저에 한 번 캐시가 되면 이를 개발자가 없앨 수 있는 방법이 없기 때문에 이런 일이 발생하지 않도록 필요한 설정이 있을 때 올바른 캐시 설정을 잘 지정해줘야 합니다.

<br />

### Cache-Control을 S3에 업로드 시 헤더 설정 vs cloudfront에서 응답값 설정

그럼 S3에서만 헤더를 설정하면 어쨌든 브라우저까지 해당 설정이 적용될 텐데, Cloudfront에서 응답값을 설정해주는 것은 어떤 의미가 있는지 궁금했습니다.

결론적으로 **적용되는 위치나 우선순위가 완전히 다르다**고 합니다.

### 1. S3 Cache-Control

이는 **원본 레벨에서 설정하는 헤더**이기 때문에, **Cloudfront가 원본으로 부터 객체를 가져올 때 해당 헤더를 참고해서 캐싱 정책을 결정**합니다. 따라서 브라우저까지 여기서 설정한 헤더가 전달이 될 수도 있고, 안될 수도 있습니다. 왜냐하면, **Cloudfront에서 설정한 Cache-Control이 있다면 이게 더 우선적으로 적용**되기 때문입니다.

### 2. Cloudfront Cache-Control

CDN 레이어에서 설정하는 캐싱 정책으로, Cloudfront가 객체를 캐싱하거나 클라이언트로 응답을 보낼 때 최종적으로 어떤 헤더를 포함할지 결정합니다. S3의 헤더와 충돌하는 경우 여기서 설정한 헤더가 우선적으로 적용합니다.

<br />

## 데이터 특성에 따른 캐싱 전략

그렇다면 프론트엔드에서 관리하는 다양한 파일들이 **모두 동일한 캐싱 전략을 사용**할까요?

보통은 그렇지 않습니다. 지금부터 각각의 파일에 대한 캐싱 전략을 알아보겠습니다.

크게 **HTML, JS/CSS 번들 파일, 이미지나 폰트와 같은 정적 데이터**가 있을 것 같습니다.

### 1. HTML

HTML은 최신 버전이 중요하고 자주 업데이트 됩니다. 따라서 아래와 같은 설정을 적용해줍니다.

<table>
    <thead>
        <tr>
            <th>레이어</th>
            <th>설정</th>
            <th>이유</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <strong>S3</strong>
            </td>
            <td>Cache-Control: s-maxage=31536000, max-age=0</td>
            <td>항상 최신 HTML 로딩 필요</td>
        </tr>
        <tr>
            <td>
                <strong>CloudFront</strong>
            </td>
            <td>Default TTL 길게 / Use Origin Cache</td>
            <td>CDN에서는 무효화를 하기 때문에 캐싱 길게</td>
        </tr>
        <tr>
            <td>
                <strong>Browser</strong>
            </td>
            <td>
                검증 요청(<code>304 Not Modified</code>) 통해 최신 여부 확인
            </td>
            <td>SPA 진입점 역할</td>
        </tr>
    </tbody>
</table>

<br />

우선 **S3**에서는 아래의 옵션값을 설정합니다.

```jsx
Cache-Control: s-maxage=31536000, max-age=0
```

-   **max-age=0** : 브라우저는 즉시 캐싱 만료 → 매번 재검증을 해야합니다.
-   **s-maxage=31536000** : CDN은 1년동안 캐싱합니다.

<br />

이렇게 적용하는 이유는 **HTML은 새 버전의 JS나 CSS를 참조**하기 때문에 HTML이 오래된 캐시이면 새로운 기능을 못쓰기 때문입니다. 따라서 HTML을 절대 max-age를 길게 설정하면 안됩니다.

```jsx
<!-- 오래된 캐시 -->
<script src="/assets/app.abc123.js"></script>
이 파일은 이미 S3에서 삭제됨 → 에러 발생
```

<br />

하지만, s-maxage 설정을 통해서 CDN의 캐싱 기간을 1년동안 가져가는데요.

실제로 이런 방식은 S3까지의 요청을 막기 때문에 응답 속도가 향상되고 S3의 부하를 감소시킬 수 있다는 장점이 있습니다. 하지만 이 방식은 배포할 때마다 Cloudfront를 무효화하기 때문에 가능한 것이고, 만약 실수로 무효화를 깜빡한다면 사용자는 옛날 버전의 HTML을 계속해서 받을 것입니다.

<br />

이러한 **HTML의 캐싱은 실제로 아래와 같이 동작**합니다.

1\. **첫 방문** : 브라우저 → Cloudfront(캐시 없음) → S3 → HTML

    이후 **Cloudfront**에 1년간 저장

2\. **새로고침** : 브라우저 → **Cloudfront**: **If-None-Match: abc123**

    **Cloudfront**: **304 Not Modified** (자체 캐시에서 응답하며 S3까지 안감)

3\. **배포 시** : Cloudfront 무효화 실행

4\. **배포 후 첫 방문** : 브라우저 → Cloudfront(캐시 없음) → S3 → 새 HTML 응답

    다시 1년간 캐싱

실제로 저희가 자주 쓰는 서비스인 [토스](https://toss.tech/article/smart-web-service-cache)에서도 이런 방식으로 캐싱을 적용해주는 것 같습니다.

<br />

**HTML도 캐시해놓고 기존 캐싱 데이터를 보내주면 효율적이지 않나? 왜 계속 요청을 하는 걸까?**

결론적으로 서비스 안정성 측면에서 HTML을 캐싱하는 것은 위험합니다.

HTML은 항상 최신 상태를 보장해야 하는 특성이 있기 때문에, 무조건적으로 Cloudfront에게 파일 내용이 검증되었는지를 확인해야 합니다.

그 이유는 HTML은 js나 css처럼 파일명이 변하지 않고 항상 index.html이기 때문에 해당 파일의 내용이 변경되었는지의 여부를 브라우저 단에서 알 수가 없기 때문입니다.

<br />

**만약 새로운 배포를 하고 Cloudfront를 무효화 했다고 하더라도, 브라우저의 캐시가 남아있게 되면 요청을 보내지 않게 되고, 결국 브라우저에서는 새로운 배포 내용을 보여주지 못하게 되는 것**입니다.

즉, HTML은 용량이 아주 작아서 검증 요청의 비용이 작기 때문에 서비스 안정성 측면에서도 필수적으로 수행되어야 합니다.

<br />

### 2. JS / CSS 번들 파일

JS 번들 파일이나 CSS 파일은 빌드를 할 때마다 해싱된 파일명으로 새롭게 생성됩니다. 그리고 이 파일명은 버전을 의미합니다.

```jsx
빌드 1 : index.abc123.js  ← 파일명에 해시 포함
빌드 2 (코드 수정) : index.def456.js  ← 파일명 자체가 바뀜
```

<br />

결과적으로 **파일명이 다르면 다른 파일이기 때문에 같은 파일명이라면 바뀔 필요가 없습**니다.

index.html에서 변경된 파일명을 추적하고 있기 때문에, JS나 CSS 파일은 max-age를 1년간 유지하는 형태로 작성해줍니다.

<table>
    <thead>
        <tr>
            <th>레이어</th>
            <th>설정</th>
            <th>이유</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <strong>S3</strong>
            </td>
            <td>Cache-Control: public, max-age=31536000, immutable</td>
            <td>해시 파일명 기반 강한 캐싱</td>
        </tr>
        <tr>
            <td>
                <strong>CloudFront</strong>
            </td>
            <td>Default TTL 길게 (1일~1년) / Use Origin Cache</td>
            <td>CDN 캐싱 극대화</td>
        </tr>
        <tr>
            <td>
                <strong>Browser</strong>
            </td>
            <td>강한 캐싱 사용</td>
            <td>파일명 바뀌면 자동 갱신</td>
        </tr>
    </tbody>
</table>

S3에서 설정하는 `public, max-age=31536000, immutable` 의 의미는 아래와 같습니다.

1\. **public**

(1) CDN, 프록시 서버 등 누구나 캐싱이 가능함

(2) private이면 브라우저만 캐싱 가능

2\. **max-age=31536000**

(1) 1년간 브라우저에서 캐싱해도 됨

(2) 브라우저와 CDN 모두 적용

3\. **immutable**

(1) 이 파일은 절대 안바뀌니, 재검증도 하지 말라는 의미 → 새로고침해도 재검증 안보냄

<br />

**재검증의 의미는 무엇일까요?**

만약, 재검증 과정이 없으면 브라우저가 서버에게 요청조차 보내지 않습니다. 즉, 기존 브라우저 캐시를 그대로 사용하게 되는 것입니다.

<br />

**Browser에서의 강한 캐싱의 의미는?**

브라우저가 **S3/Cloudfront에서 받은 헤더를 자동으로 따른다**는 의미입니다.

즉, 이건 immutable 속성이 있기 때문에 새로고침을 해도 cloudfront에게 파일이 변경되었는지 확인하는 요청을 보내는 것이 아닌, 기존에 있는 브라우저 캐시를 사용해주는 것을 의미합니다.

<br />

**왜 파일명이 바뀌면 자동으로 새 파일을 받을까요?**

```jsx
<!-- 옛날 HTML (캐시됨) -->
<script src="/assets/index.abc123.js"></script>

브라우저 캐시 - index.abc123.js (1년간 유효)
```

이후 새로운 HTML을 배포하면 js 파일명이 바뀌었을 때, script 태그를 만나면 새로 다운로드 하게 됩니다.

```jsx
<!-- 새 HTML (배포 후) -->
<script src="/assets/index.def456.js"></script>

브라우저: "index.def456.js? 캐시에 없네!" → 다운로드 요청
```

<br />

### 3. 정적 이미지

보통 로고나 아이콘과 같은 변하지 않는 에셋들이 이에 해당하는데요. 변경될 가능성이 적기 때문에 JS,CSS 번들 파일과 마찬가지로 max-age를 길게 설정해줍니다.

<table>
    <thead>
        <tr>
            <th>레이어</th>
            <th>설정</th>
            <th>이유</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <strong>S3</strong>
            </td>
            <td>
                <code>Cache-Control: public, max-age=31536000, immutable</code>
            </td>
            <td>변경 거의 없음</td>
        </tr>
        <tr>
            <td>
                <strong>CloudFront</strong>
            </td>
            <td>TTL 길게</td>
            <td>성능 및 비용 절감</td>
        </tr>
        <tr>
            <td>
                <strong>Browser</strong>
            </td>
            <td>강한 캐싱</td>
            <td>즉시 표시</td>
        </tr>
    </tbody>
</table>

<br />

정리하자면 아래와 같습니다. 각각의 리소스 별로 S3에서 설정하는 헤더가 다르므로 각 리소스에 맞는 설정이 필수적일 것 같습니다.

<table>
    <thead>
        <tr>
            <th>리소스 종류</th>
            <th>S3 설정</th>
            <th>CloudFront</th>
            <th>Browser</th>
            <th>버전 방식</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>HTML</td>
            <td>
                <code>s-maxage=31536000, max-age=0</code>
            </td>
            <td>TTL 길게</td>
            <td>약한 캐싱</td>
            <td>필요 없음</td>
        </tr>
        <tr>
            <td>JS / CSS</td>
            <td>
                <code>max-age=31536000, immutable</code>
            </td>
            <td>TTL 길게</td>
            <td>강한 캐싱</td>
            <td>파일명 해시</td>
        </tr>
        <tr>
            <td>정적 이미지, 폰트</td>
            <td>
                <code>max-age=31536000, immutable</code>
            </td>
            <td>TTL 길게</td>
            <td>강한 캐싱</td>
            <td>파일명 해시</td>
        </tr>
    </tbody>
</table>

<br />

# 정리

웹 애플리케이션의 캐싱 전략은 리소스 특성에 따라 달라집니다.

1\. **HTML**: 항상 최신 버전을 제공해야 하므로 브라우저 캐싱은 짧게, CDN 캐싱은 길게 설정하되 배포 시 무효화를 통해 관리합니다.

2\. **JS/CSS 번들**: 파일명에 해시를 포함하여 버전을 관리하므로, 브라우저와 CDN 모두 강한 캐싱을 적용할 수 있습니다.

3\. **정적 에셋**: 변경이 거의 없으므로 JS/CSS와 동일하게 강한 캐싱 전략을 사용합니다.

S3, CloudFront, 브라우저 각 레이어에서의 역할을 이해하고 적절한 캐싱 설정을 적용하면, 성능 개선과 비용 절감을 동시에 달성할 수 있습니다.

<br />

# 마무리하며

이번 캐싱 전략 적용을 통해 단순히 이미지 로딩 속도를 개선하는 것을 넘어, 전체 서비스의 캐싱 구조를 이해하고 정리할 수 있었습니다.

특히 HTML, JS/CSS, 정적 에셋 각각의 특성에 맞는 캐싱 전략을 수립하면서, 왜 이런 방식으로 설정해야 하는지에 대한 명확한 이유를 알게 되었습니다.

앞으로도 서비스 특성에 맞는 캐싱 전략을 고민하고 적용할 수 있을 것 같습니다.

웹 캐시에 대해 고민하고 있는 분들에게 도움이 되었으면 좋겠습니다.

감사합니다.

<br />

## 참고 자료

[https://toss.tech/article/smart-web-service-cache](https://toss.tech/article/smart-web-service-cache)
